
<!DOCTYPE html>
<html>
<head>     <link href="prism.css" rel="stylesheet"> <script >  	var admobid = {}; if( /(android)/i.test(navigator.userAgent) ) {     admobid = {            banner: 'ca-app-pub-5170973579111533/1085713519',        interstitial: 'ca-app-pub-5170973579111533/8936283376'     }; } else if(/(ipod|iphone|ipad)/i.test(navigator.userAgent)) {     admobid = {            banner: 'ca-app-pub-6869992474017983/4806197152',         interstitial: 'ca-app-pub-6869992474017983/7563979554'     }; } else {     admobid = {              banner: 'ca-app-pub-6869992474017983/8878394753',         interstitial: 'ca-app-pub-6869992474017983/1355127956'     }; } if(( /(ipad|iphone|ipod|android|windows phone)/i.test(navigator.userAgent) )) {     document.addEventListener('deviceready', initApp, false); } else {     initApp(); }  function initApp() {     if (! AdMob ) { alert( 'admob plugin not ready' ); return; }       AdMob.createBanner( {         adId: admobid.banner,         isTesting: false,         overlap: false,         offsetTopBar: false,         position: AdMob.AD_POSITION.BOTTOM_CENTER,         bgColor: 'black'     } );      AdMob.prepareInterstitial({         adId: admobid.interstitial,         autoShow: false     }); }    </script></head>
<body style="background-color:white;" >
<script type="text/javascript" src="prism.js"></script>

<pre class="language-java"><code>








/*
Tag Content Extractor

In a tag based language, like XML or HTML, contents are enclosed by a start tag and an end tag. For example:

&lttag&gtcontents&lt/tag&gt
In this problem, you will be given a text in a tag based language. Your task is to parse this text and retrieve 
the contents which are enclosed by well organized tag sequences. Well organized tags maintain the following constraints:

The name of the start and end tag must be same. The following HTML code is not valid:

&lth1&gtHello World&lt/h2&gt
Tag can be nested, but there will be no content in between the nested tags. The following code is not valid:

<h1><a>contents</a>invalid</h1>
Tags can consist of any printable characters.

Input Format

The first line of input contains a single integer N, representing the number of lines. The next N lines 
contains a line of text.

Constraints

1&lt=N&lt=100
Each line contains at most 104 printable characters. The total number of characters in all test cases will not exceed 106.

Output Format

For each line, print the valid content enclosed by proper tags. If there is multiple valid content in a test case, 
print out each of the valid content on separate lines. If no valid content is found in a test case, print "None" without quotes.

Sample Input

4
&lth1&gtNayeem loves counseling&lt/h1&gt
&lth1&lth1&gtSanjay has no watch&lt/h1&gt&lt/h1&gt&ltpar&gtSo wait for a while&ltpar&gt
&ltAmee&gtsafat codes like a ninja&lt/amee&gt
&ltSA premium&gtImtiaz has a secret crush&lt/SA premium&gt

Sample Output

Nayeem loves counseling
Sanjay has no watch
So wait for a while
None
Imtiaz has a secret crush
*/


import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class TagContentExtractor{
   
   public static void main(String[] args){
   	
       Scanner in = new Scanner(System.in);
       int testCases = Integer.parseInt(in.nextLine());
       String regexPatern = "(&lt[^&gt]*>)";
       Pattern stringPatern  = Pattern.compile(regexPatern);
      	while(testCases>0){
      		String line = in.nextLine();
          	int pos = 0;
          	Matcher m = stringPatern.matcher(line);
          	String previousHTMLTag = null;
          	int previousTagPos = -1;
          	boolean didFind = false;
          	while(m.find())
          	{	
              	String htmlTag = line.substring(m.start(),m.end());
              	if(htmlTag.charAt(1) != '/')
              	{
	            	previousHTMLTag = htmlTag;
	               	previousTagPos = m.end();
              	}else if(htmlTag.charAt(1) == '/' && previousHTMLTag != null){
                  	if(previousHTMLTag.substring(1).equals(htmlTag.substring(2))&&previousHTMLTag.length()>2 && m.start()>previousTagPos+1){
                    	System.out.println(line.substring(previousTagPos,m.start()));
                      	didFind = true;
                  	}
                	previousHTMLTag = null;
              	}
                  
          	}
          	System.out.print(didFind?"":"None\n");
          	testCases--;
        }
          
    }
}


        </code></pre>
  </body>
</html>		
